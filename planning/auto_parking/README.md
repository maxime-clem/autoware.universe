# auto_parking

## auto_parking_node

`auto_parking_node` is a node that enables automated valet parking by publishing appropriate goal poses towards an empty parking space in the nearest parking lot.

The auto parking is done in the following two phases.

Phase 1:
Depending on initial pose when the auto parking feature is engaged, a goal pose is set at the exit of the nearest parking lot. This pose is found by first getting nearest parking lot, the parking spaces inside and lanelets inside the parking lot from the lanelet map. By ordering the lanelets based on routing distance from current position, the exit lanelet is found. Ideally the auto_parking feature should be engaged from outside parking lot so the ordering is proper. The ego vehicle then drives to parking lot exit lanelets, passing through the parking lot using either LANEDRIVING or PARKING scenario based on start pose.

Phase 2:
Once inside the parking lot, while driving to exit lanelet goal, the node searches for a free parking space using the astar algorithm. Once a free space is found a new goal pose is published and trajectory is generated by the freespace_planner as scenario is PARKING.

### Input topics

| Name                      | Type                                    | Description                           |
| ------------------------- | --------------------------------------- | ------------------------------------- |
| `~/input/engage`          | autoware_auto_vehicle_msgs::msg::Engage | status of autoware AUTONOMOUS         |
| `~/input/lanelet_map_bin` | autoware_auto_mapping_msgs::HADMapBin   | vector map, for drivable areas        |
| `~/input/occupancy_grid`  | nav_msgs::msg::OccupancyGrid            | occupancy grid from costmap generator |
| `~input/odometry`         | nav_msgs::Odometry                      | for getting current pose              |

### Output topics

| Name                     | Type                            | Description                            |
| ------------------------ | ------------------------------- | -------------------------------------- |
| `~/output/fixed_goal`    | geometry_msgs::msg::PoseStamped | current goal published by auto_parking |
| `~/output/active_status` | std_msgs::msg::Bool             | active status of auto_park node        |

### Service

| Name                   | Type                   | Description               |
| ---------------------- | ---------------------- | ------------------------- |
| `~/service/set_active` | std_srvs::srv::SetBool | set active status of node |

### Client

| Name               | Type                                 | Description                      |
| ------------------ | ------------------------------------ | -------------------------------- |
| `~/service/engage` | tier4_external_api_msgs::srv::Engage | client to engage AUTONOMOUS mode |

### How to launch

1. Write your remapping info in `auto-parking.launch.xml` or add args when executing `roslaunch`
2. Launch node using `ros2 launch auto-parking auto-parking.launch.xml`
3. Call service to start auto parking after placing ego on map `ros2 service call /planning/auto_parking/set_status std_srvs/srv/SetBool "{data: True}"`
4. To stop/reset call with False arg `ros2 service call /planning/auto_parking/set_status std_srvs/srv/SetBool "{data: False}"`

### Parameters

{{ json_to_markdown("schema/auto_parking.schema.json") }}

### Flowchart

```plantuml
@startuml
title onTimer
start

if (active?) then (yes)
else (no)
  stop
endif

if (all input data are ready?) then (yes)
else (no)
  :set active false;
  stop
endif

:get current pose;

if (parking lot goal not set and set AutoParking init?) then (yes):
  :publish parking lot goal;
else (no)
  stop
endif

if (parking lot goal set and Arrived?) then (yes):
  :set active false;
  stop
endif

if (parking space goal not set and inside ParkingLot?) then (yes):
  :findParkingSapce;
  :publish parking space goal;
endif

if (parking space goal set and inside ParkingLot?) then (yes):
  :check if parking space goal still valid;
  if (not valid) then (yes):
    :publish parking lot goal;
    :continue search;
  endif
endif

if (parking space goal set and Arrived?) then (yes):
  stop
endif

if (autonomous not engaged?) then (yes):
  :engage autonomous;
endif

stop
@enduml
```
